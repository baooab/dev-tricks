import{o as n,c as s,a}from"./app.d2ac5229.js";const e='{"title":"","description":"","frontmatter":{},"headers":[{"level":2,"title":"Control Flow Based Type Analysis","slug":"control-flow-based-type-analysis"},{"level":2,"title":"Strict Null Checks","slug":"strict-null-checks"},{"level":2,"title":"Definite Assignment Analysis","slug":"definite-assignment-analysis"},{"level":2,"title":"Summary","slug":"summary"}],"relativePath":"typescript/control-flow-based-type-analysis-in-typescript.md","lastUpdated":1640347620244}',t={},o=a('<h1 id="control-flow-based-type-analysis-in-typescript"><a class="header-anchor" href="#control-flow-based-type-analysis-in-typescript" aria-hidden="true">#</a> Control Flow Based Type Analysis in TypeScript</h1><blockquote><p>Marius Schulz, <a href="https://mariusschulz.com/blog/control-flow-based-type-analysis-in-typescript" target="_blank" rel="noopener noreferrer">“Control Flow Based Type Analysis in TypeScript”</a>, September 30, 2016</p></blockquote><p>The <a href="https://blogs.msdn.microsoft.com/typescript/2016/09/22/announcing-typescript-2-0/" target="_blank" rel="noopener noreferrer">recent release</a> of TypeScript 2.0 shipped with plenty of new features. I previously wrote about the new <a href="/blog/non-nullable-types-in-typescript.html">non-nullable types</a>, which go hand in hand with another feature we&#39;re going to look at in this post: type analysis based on control flow.</p><h2 id="control-flow-based-type-analysis"><a class="header-anchor" href="#control-flow-based-type-analysis" aria-hidden="true">#</a> Control Flow Based Type Analysis</h2><p>The official <a href="https://github.com/Microsoft/TypeScript/wiki/What&#39;s-new-in-TypeScript#control-flow-based-type-analysis" target="_blank" rel="noopener noreferrer">What&#39;s new in TypeScript</a> page summarizes control flow based type analysis as follows:</p><blockquote><p>With TypeScript 2.0, the type checker analyses all possible flows of control in statements and expressions to produce the most specific type possible (the <em>narrowed type</em>) at any given location for a local variable or parameter that is declared to have a union type.</p></blockquote><p>That&#39;s a pretty dense explanation. Here&#39;s an example that illustrates how TypeScript understands the effect of assignments to a local variable, and how it <em>narrows</em> the type of that variable accordingly:</p><div class="language-ts line-numbers-mode"><pre><code><span class="token keyword">let</span> command<span class="token operator">:</span> <span class="token builtin">string</span> <span class="token operator">|</span> <span class="token builtin">string</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>\n\ncommand <span class="token operator">=</span> <span class="token string">&quot;pwd&quot;</span><span class="token punctuation">;</span>\ncommand<span class="token punctuation">.</span><span class="token function">toLowerCase</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Here, command is of type &#39;string&#39;</span>\n\ncommand <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">&quot;ls&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;-la&quot;</span><span class="token punctuation">]</span><span class="token punctuation">;</span>\ncommand<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token string">&quot; &quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Here, command is of type &#39;string[]&#39;</span>\n</code></pre><div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>Note that all code resides within the same scope. Still, the type checker uses the most specific type possible for the <code>command</code> variable at any given location:</p><ul><li>After the string <code>&quot;pwd&quot;</code> has been assigned, there&#39;s no way for the <code>command</code> variable to be a string array (the only other option within the union type). Therefore, TypeScript treats <code>command</code> as a variable of type <code>string</code> and allows the call to the <code>toLowerCase()</code> method.</li><li>After the string array <code>[&quot;ls&quot;, &quot;-la&quot;]</code> is assigned, the <code>command</code> variable is no longer treated as a string. It is now known to be a string array, so the call to the <code>join</code> method succeeds.</li></ul><p>Because of the same control flow analysis, the following function type-checks correctly in TypeScript 2.0:</p><div class="language-ts line-numbers-mode"><pre><code><span class="token keyword">function</span> <span class="token function">composeCommand</span><span class="token punctuation">(</span>command<span class="token operator">:</span> <span class="token builtin">string</span> <span class="token operator">|</span> <span class="token builtin">string</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">string</span> <span class="token punctuation">{</span>\n    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> command <span class="token operator">===</span> <span class="token string">&quot;string&quot;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">return</span> command<span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n\n    <span class="token keyword">return</span> command<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token string">&quot; &quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>The compiler now understands that if the <code>command</code> parameter is of type <code>string</code>, the function always returns early from within the <code>if</code>-statement. Because of the early exit behavior, the type of the <code>command</code> parameter is narrowed to <code>string[]</code> after the <code>if</code>-statement. As a result, the call to the <code>join</code> method type-checks correctly.</p><p>Prior to TypeScript 2.0, the compiler was not able to deduce the above semantics. Therefore, the <code>string</code> type was not removed from the union type of the <code>command</code> variable, and the following compile-time error was produced:</p><div class="language-"><pre><code>Property &#39;join&#39; does not exist on type &#39;string | string[]&#39;.\n</code></pre><div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><h2 id="strict-null-checks"><a class="header-anchor" href="#strict-null-checks" aria-hidden="true">#</a> Strict Null Checks</h2><p>Control flow based type analysis is particularly helpful when used in conjunction with nullable types, which are represented using union types including <code>null</code> or <code>undefined</code>. Usually, we need to check whether a variable of a nullable type has a non-null value before we can work with it:</p><div class="language-ts line-numbers-mode"><pre><code><span class="token keyword">type</span> <span class="token class-name">Person</span> <span class="token operator">=</span> <span class="token punctuation">{</span>\n    firstName<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span>\n    lastName<span class="token operator">?</span><span class="token operator">:</span> <span class="token builtin">string</span> <span class="token operator">|</span> <span class="token keyword">null</span> <span class="token operator">|</span> <span class="token keyword">undefined</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span><span class="token punctuation">;</span>\n\n<span class="token keyword">function</span> <span class="token function">getFullName</span><span class="token punctuation">(</span>person<span class="token operator">:</span> Person<span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">string</span> <span class="token punctuation">{</span>\n    <span class="token keyword">const</span> <span class="token punctuation">{</span> firstName<span class="token punctuation">,</span> lastName <span class="token punctuation">}</span> <span class="token operator">=</span> person<span class="token punctuation">;</span>\n\n    <span class="token comment">// Here, we check for a falsy value of the `lastName` property,</span>\n    <span class="token comment">// which covers `null` and `undefined` (and other values like &quot;&quot;)</span>\n    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>lastName<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">return</span> firstName<span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n\n    <span class="token keyword">return</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>firstName<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string"> </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>lastName<span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br></div></div><p>Here, the <code>Person</code> type defines a non-nullable <code>firstName</code> property and a nullable <code>lastName</code> property. If we compose a full name out of both, we need to check whether <code>lastName</code> is <code>null</code> or <code>undefined</code> to avoid appending the string <code>&quot;null&quot;</code> or <code>&quot;undefined&quot;</code> to the first name.</p><p>For the purpose of clarity, I added the <code>undefined</code> type to the union type of the <code>lastName</code> property, although that&#39;s a redundant piece of information. In strict null checking mode, the <code>undefined</code> type is added automatically to the union type of optional properties, so we don&#39;t have to explicitly write it out. For more information, please refer to my previous post about <a href="/blog/non-nullable-types-in-typescript.html">non-nullable types</a>.</p><h2 id="definite-assignment-analysis"><a class="header-anchor" href="#definite-assignment-analysis" aria-hidden="true">#</a> Definite Assignment Analysis</h2><p>Another new feature built on top of control flow is <strong>definite assignment analysis</strong>. In strict null checking mode, local variables cannot be referenced before they have been assigned:</p><div class="language-ts line-numbers-mode"><pre><code><span class="token keyword">let</span> name<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span>\n\n<span class="token comment">// Error: Variable &#39;name&#39; is used before being assigned.</span>\n<span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>\n</code></pre><div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>An exception to this rule are local variables whose type includes <code>undefined</code>:</p><div class="language-ts line-numbers-mode"><pre><code><span class="token keyword">let</span> name<span class="token operator">:</span> <span class="token builtin">string</span> <span class="token operator">|</span> <span class="token keyword">undefined</span><span class="token punctuation">;</span>\n<span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// No error</span>\n</code></pre><div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>Definite assignment analysis is another protection measure against nullability bugs. The idea is to make sure that every non-nullable local variable has been initialized properly before it&#39;s being used.</p><h2 id="summary"><a class="header-anchor" href="#summary" aria-hidden="true">#</a> Summary</h2><p>Control flow based type analysis is a powerful addition to TypeScript&#39;s type system. The type checker now understands the semantics of assignments and jumps in control flow, thereby greatly reducing the need for type guards. Working with nullable variables can be facilitated by the elimination of the <code>null</code> and <code>undefined</code> types. Finally, control flow analysis prevents referencing variables that have not definitely been assigned at the given location.</p><p>本篇文章是 <a href="https://mariusschulz.com/blog/series/typescript-evolution" target="_blank" rel="noopener noreferrer">TypeScript Evolution</a> 系列中的一篇。</p>',29);t.render=function(a,e,t,p,l,c){return n(),s("div",null,[o])};export default t;export{e as __pageData};
