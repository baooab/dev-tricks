import{o as n,c as s,a}from"./app.808b26de.js";const e='{"title":"","description":"","frontmatter":{},"headers":[{"level":2,"title":"基于控制流的类型分析","slug":"基于控制流的类型分析"},{"level":2,"title":"严格空值检查","slug":"严格空值检查"},{"level":2,"title":"明确赋值分析","slug":"明确赋值分析"},{"level":2,"title":"总结","slug":"总结"}],"relativePath":"typescript/control-flow-based-type-analysis-in-typescript.md","lastUpdated":1640914991665}',p={},t=a('<h1 id="typescript：基于控制流的类型分析"><a class="header-anchor" href="#typescript：基于控制流的类型分析" aria-hidden="true">#</a> TypeScript：基于控制流的类型分析</h1><blockquote><p>Marius Schulz, <a href="https://mariusschulz.com/blog/control-flow-based-type-analysis-in-typescript" target="_blank" rel="noopener noreferrer">“Control Flow Based Type Analysis in TypeScript”</a>, September 30, 2016</p></blockquote><p><a href="https://blogs.msdn.microsoft.com/typescript/2016/09/22/announcing-typescript-2-0/" target="_blank" rel="noopener noreferrer">TypeScript 2.0</a> 带来了很多新特新。除了已经介绍的 <a href="./non-nullable-types-in-typescript.html">非空类型</a>，还有基于控制流的类型分析。</p><h2 id="基于控制流的类型分析"><a class="header-anchor" href="#基于控制流的类型分析" aria-hidden="true">#</a> 基于控制流的类型分析</h2><p>官方的 <a href="https://github.com/Microsoft/TypeScript/wiki/What&#39;s-new-in-TypeScript#control-flow-based-type-analysis" target="_blank" rel="noopener noreferrer">What&#39;s new in TypeScript</a> 页面总结了基于控制流的类型分析：</p><blockquote><p>With TypeScript 2.0, the type checker analyses all possible flows of control in statements and expressions to produce the most specific type possible (the <em>narrowed type</em>) at any given location for a local variable or parameter that is declared to have a union type.</p></blockquote><p>这是一个非常冗长的解释。下面，我们用一个例子来说明 TypeScript 是如何理解变量赋值，以及缩小变量类型范围的。</p><div class="language-ts line-numbers-mode"><pre><code><span class="token keyword">let</span> command<span class="token operator">:</span> <span class="token builtin">string</span> <span class="token operator">|</span> <span class="token builtin">string</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>\n\ncommand <span class="token operator">=</span> <span class="token string">&quot;pwd&quot;</span><span class="token punctuation">;</span>\ncommand<span class="token punctuation">.</span><span class="token function">toLowerCase</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Here, command is of type &#39;string&#39;</span>\n\ncommand <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">&quot;ls&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;-la&quot;</span><span class="token punctuation">]</span><span class="token punctuation">;</span>\ncommand<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token string">&quot; &quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Here, command is of type &#39;string[]&#39;</span>\n</code></pre><div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>注意，所有的代码都处在同一个作用域中。同样，类型检查器也会根据变量 <code>command</code> 所处的位置，判定它应该是什么具体类型：</p><ul><li><code>command</code> 赋值为字符串 <code>&quot;pwd&quot;</code> 后，就不再可能是一个字符串数组了（联合类型中唯一的另一个选项）。因此，TypeScript 认为 <code>command</code> 是一个 <code>string</code> 类型的变量，就能调用字符串方法 <code>toLowserCase()</code>。</li><li>同理，<code>command</code> 赋值为字符串数组 <code>[&quot;ls&quot;, &quot;-la&quot;]</code> 后，就不再可能是一个字符串了。因此，就能调用数组方法 <code>join()</code>。</li></ul><p>同样是根据控制流分析，下面函数里的类型检查在 TypeScript 2.0 看来也是正确的：</p><div class="language-ts line-numbers-mode"><pre><code><span class="token keyword">function</span> <span class="token function">composeCommand</span><span class="token punctuation">(</span>command<span class="token operator">:</span> <span class="token builtin">string</span> <span class="token operator">|</span> <span class="token builtin">string</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">string</span> <span class="token punctuation">{</span>\n    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> command <span class="token operator">===</span> <span class="token string">&quot;string&quot;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token keyword">return</span> command<span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n\n    <span class="token keyword">return</span> command<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token string">&quot; &quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>编译器现在理解，<code>if</code> 语句里的 <code>command</code> 是 <code>string</code> 类型，进入这个分支函数会提前返回。如果没走这个分支，那么 <code>command</code> 只可能是 <code>string[]</code> 类型，所以在调用 <code>join()</code> 方法的时候，被认定为类型正确。</p><p>TypeScript 2.0 之前，编译器是无法推断出上述语义的。因此，<code>string</code> 类型不会从 <code>command</code> 变量所属的联合类型中移除，就会产生如下的编译期错误：</p><div class="language-"><pre><code>Property &#39;join&#39; does not exist on type &#39;string | string[]&#39;.\n</code></pre><div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><h2 id="严格空值检查"><a class="header-anchor" href="#严格空值检查" aria-hidden="true">#</a> 严格空值检查</h2><p>基于控制流的类型分析与空类型结合使用的时候特别有用。比如，我们在操作值之前，通常会做一个是否为空的判断，这样就能把可为空变量的空值情况排除掉：</p><div class="language-ts line-numbers-mode"><pre><code><span class="token keyword">type</span> <span class="token class-name">Person</span> <span class="token operator">=</span> <span class="token punctuation">{</span>\n    firstName<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span>\n    lastName<span class="token operator">?</span><span class="token operator">:</span> <span class="token builtin">string</span> <span class="token operator">|</span> <span class="token keyword">null</span> <span class="token operator">|</span> <span class="token keyword">undefined</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span><span class="token punctuation">;</span>\n\n<span class="token keyword">function</span> <span class="token function">getFullName</span><span class="token punctuation">(</span>person<span class="token operator">:</span> Person<span class="token punctuation">)</span><span class="token operator">:</span> <span class="token builtin">string</span> <span class="token punctuation">{</span>\n    <span class="token keyword">const</span> <span class="token punctuation">{</span> firstName<span class="token punctuation">,</span> lastName <span class="token punctuation">}</span> <span class="token operator">=</span> person<span class="token punctuation">;</span>\n\n    <span class="token comment">// Here, we check for a falsy value of the `lastName` property,</span>\n    <span class="token comment">// which covers `null` and `undefined` (and other values like &quot;&quot;)</span>\n    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>lastName<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">return</span> firstName<span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n\n    <span class="token keyword">return</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>firstName<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string"> </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>lastName<span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br></div></div><p>上例中，<code>Person</code> 类型定义了一个非空属性 <code>firstName</code> 和可为空属性 <code>lastName</code>。在将它们组合成一个完整姓名的时候，我们需要先判断 <code>lastName</code> 为 <code>null</code> 或 <code>undefined</code> 的情况，这样就能避免输出结果中出现 <code>&quot;null&quot;</code> 或 <code>&quot;undefined&quot;</code>。</p><p>为了清楚起见，我给属性 <code>lastName</code> 所在的类型加了一个 <code>undefined</code>，虽然这么写是没必要的。在严格空值检查模式下，<code>undefined</code> 类型会自动加入可选属性的类型上，因此无需显式写出来。更多这方面的内容，可以参考 <a href="./non-nullable-types-in-typescript.html">非空类型</a> 这篇文章。</p><h2 id="明确赋值分析"><a class="header-anchor" href="#明确赋值分析" aria-hidden="true">#</a> 明确赋值分析</h2><p>另一个基于控制流的新特性是 <strong>明确赋值分析（definite assignment analysis）</strong>。在严格空值检查模式下，本地变量在使用前必须要先赋值：</p><div class="language-ts line-numbers-mode"><pre><code><span class="token keyword">let</span> name<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span>\n\n<span class="token comment">// Error: Variable &#39;name&#39; is used before being assigned.</span>\n<span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>\n</code></pre><div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>当然，如果变量允许为空（比如允许 <code>undefined</code>），就不会有问题：</p><div class="language-ts line-numbers-mode"><pre><code><span class="token keyword">let</span> name<span class="token operator">:</span> <span class="token builtin">string</span> <span class="token operator">|</span> <span class="token keyword">undefined</span><span class="token punctuation">;</span>\n<span class="token builtin">console</span><span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// No error</span>\n</code></pre><div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>明确赋值分析是另一个避免空值调用 BUG 的保护措施。这个功能是为了保证任何非空变量在使用前被正确的初始化了。</p><h2 id="总结"><a class="header-anchor" href="#总结" aria-hidden="true">#</a> 总结</h2><p>基于控制流的类型分析是 TypeScript 类型系统一个特别强大的功能添加。类型检查器理解控制流中的赋值和分支语义，极大地减少了使用 type guard 的必要。通过消除“null”和“undefined”类型，可以方便地处理可为空变量。最后，控制流分析避免了在使用变量前没有明确赋值的问题。</p><p>本篇文章是 <a href="https://mariusschulz.com/blog/series/typescript-evolution" target="_blank" rel="noopener noreferrer">TypeScript Evolution</a> 系列中的一篇。</p>',29);p.render=function(a,e,p,o,c,l){return n(),s("div",null,[t])};export default p;export{e as __pageData};
