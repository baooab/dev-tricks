import{o as n,c as s,a}from"./app.808b26de.js";const e='{"title":"","description":"","frontmatter":{},"headers":[{"level":2,"title":"布尔字面量类型","slug":"布尔字面量类型"},{"level":2,"title":"数值字面量类型","slug":"数值字面量类型"},{"level":2,"title":"枚举字面量类型","slug":"枚举字面量类型"}],"relativePath":"typescript/more-literal-types-in-typescript.md","lastUpdated":1642335454147}',p={},t=a('<h1 id="typescript-2-0-中增加的字面量类型"><a class="header-anchor" href="#typescript-2-0-中增加的字面量类型" aria-hidden="true">#</a> TypeScript 2.0 中增加的字面量类型</h1><blockquote><p>Marius Schulz, <a href="https://mariusschulz.com/blog/more-literal-types-in-typescript" target="_blank" rel="noopener noreferrer">“More Literal Types in TypeScript”</a>, November 10, 2016</p></blockquote><p>TypeScript 1.8 引入了 <a href="https://mariusschulz.com/blog/string-literal-types-in-typescript" target="_blank" rel="noopener noreferrer">字符串字面量</a>，将变量限制为有限的字符串集合。TypeScript 2.0 中又向类型系统中新增了下面三个字面量类型：</p><ul><li><a href="#boolean-literal-types">布尔字面量类型</a></li><li><a href="#numeric-literal-types">数值字面量类型</a></li><li><a href="#enum-literal-types">枚举字面量类型</a></li></ul><p>接下来，我们将逐个进行讲解，并搭配一些实际的案例。</p><h2 id="布尔字面量类型"><a class="header-anchor" href="#布尔字面量类型" aria-hidden="true">#</a> 布尔字面量类型</h2><p>下面的例子中定义了两个常量：<code>TRUE</code> 和 <code>FALSE</code>，分别被赋值 <code>true</code> 和 <code>false</code>。</p><div class="language-ts line-numbers-mode"><pre><code><span class="token keyword">const</span> <span class="token constant">TRUE</span><span class="token operator">:</span> <span class="token boolean">true</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span> <span class="token comment">// OK</span>\n<span class="token keyword">const</span> <span class="token constant">FALSE</span><span class="token operator">:</span> <span class="token boolean">false</span> <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span> <span class="token comment">// OK=</span>\n</code></pre><div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>尝试给每个变量赋值相反的值会导致类型错误：</p><div class="language-ts line-numbers-mode"><pre><code><span class="token keyword">const</span> <span class="token constant">TRUE</span><span class="token operator">:</span> <span class="token boolean">true</span> <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>\n<span class="token comment">// Error: Type &#39;false&#39; is not assignable to type &#39;true&#39;</span>\n\n<span class="token keyword">const</span> <span class="token constant">FALSE</span><span class="token operator">:</span> <span class="token boolean">false</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>\n<span class="token comment">// Error: Type &#39;true&#39; is not assignable to type &#39;false&#39;</span>\n</code></pre><div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>随着布尔字面量类型的引入，预置 <code>boolean</code> 类型等价于联合类型 <code>true | false</code>：</p><div class="language-ts line-numbers-mode"><pre><code><span class="token keyword">let</span> value<span class="token operator">:</span> <span class="token boolean">true</span> <span class="token operator">|</span> <span class="token boolean">false</span><span class="token punctuation">;</span> <span class="token comment">// Type boolean</span>\n</code></pre><div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>While boolean literal types are rarely useful in isolation, they work great in conjunction with <a href="/blog/tagged-union-types-in-typescript.html">tagged union types</a> and <a href="/blog/control-flow-based-type-analysis-in-typescript.html">control flow based type analysis</a>. For instance, a generic <code>Result&lt;T&gt;</code> type that either holds a value of type <code>T</code> or an error message of type <code>string</code> can be defined as follows:</p><p>布尔字面量类型很少单独使用，不过可以跟 <a href="./tagged-union-types-in-typescript.html">标签联合类型</a> 和 <a href="./control-flow-based-type-analysis-in-typescript.html">基于类型分析的控制流</a> 很好的配合使用。比如，我们定义了一个范型 <code>Reresult&lt;T&gt;</code>，既支持接收类型 <code>T</code> 的值，也支持接收字符串类型的值作为错误信息：</p><div class="language-ts line-numbers-mode"><pre><code><span class="token keyword">type</span> <span class="token class-name">Result<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span></span> <span class="token operator">=</span>\n    <span class="token operator">|</span> <span class="token punctuation">{</span> success<span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">;</span> value<span class="token operator">:</span> <span class="token constant">T</span> <span class="token punctuation">}</span>\n    <span class="token operator">|</span> <span class="token punctuation">{</span> success<span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">;</span> error<span class="token operator">:</span> <span class="token builtin">string</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>\n</code></pre><div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>有一个接受单参数的函数。</p><div class="language-ts line-numbers-mode"><pre><code><span class="token keyword">function</span> <span class="token function">parseEmailAddress</span><span class="token punctuation">(</span>\n    input<span class="token operator">:</span> <span class="token builtin">string</span> <span class="token operator">|</span> <span class="token keyword">null</span> <span class="token operator">|</span> <span class="token keyword">undefined</span>\n<span class="token punctuation">)</span><span class="token operator">:</span> Result<span class="token operator">&lt;</span><span class="token builtin">string</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span>\n    <span class="token comment">// If the input is null, undefined, or the empty string</span>\n    <span class="token comment">// (all of which are falsy values), we return early.</span>\n    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>input<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token keyword">return</span> <span class="token punctuation">{</span>\n            success<span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span>\n            error<span class="token operator">:</span> <span class="token string">&quot;The email address cannot be empty.&quot;</span>\n        <span class="token punctuation">}</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n\n    <span class="token comment">// We&#39;re only checking that the input matches the pattern</span>\n    <span class="token comment">//   &lt;something&gt; @ &lt;something&gt; DOT &lt;something&gt;</span>\n    <span class="token comment">// to keep it simple. Properly validating email addresses</span>\n    <span class="token comment">// via regex is hard, so let&#39;s not even try here.</span>\n    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">^\\S[email protected]\\S+\\.\\S+$</span><span class="token regex-delimiter">/</span></span><span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span>input<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token keyword">return</span> <span class="token punctuation">{</span>\n            success<span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span>\n            error<span class="token operator">:</span> <span class="token string">&quot;The email address has an invalid format.&quot;</span>\n        <span class="token punctuation">}</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n\n    <span class="token comment">// At this point, control flow based type analysis</span>\n    <span class="token comment">// has determined that the input has type string.</span>\n    <span class="token comment">// Thus, we can assign input to the value property.</span>\n    <span class="token keyword">return</span> <span class="token punctuation">{</span>\n        success<span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>\n        value<span class="token operator">:</span> input\n    <span class="token punctuation">}</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br></div></div><p>注意，启用 <code>strictNullChecks</code> 选项的时候，<code>string</code> 是 <a href="./non-nullable-types-in-typescript.html">非空类型</a>。为了让函数的 <code>input</code> 参数接受一个可为空类型的值，<code>null</code> 和 <code>undefined</code> 必须显式地包含在联合类型中。</p><p>现在调用 <code>parseEmailFunction</code>：</p><div class="language-ts line-numbers-mode"><pre><code><span class="token keyword">const</span> parsed <span class="token operator">=</span> <span class="token function">parseEmailAddress</span><span class="token punctuation">(</span><span class="token string">&quot;[email protected]&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n<span class="token keyword">if</span> <span class="token punctuation">(</span>parsed<span class="token punctuation">.</span>success<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    parsed<span class="token punctuation">.</span>value<span class="token punctuation">;</span> <span class="token comment">// OK</span>\n    parsed<span class="token punctuation">.</span>error<span class="token punctuation">;</span> <span class="token comment">// Error</span>\n<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>\n    parsed<span class="token punctuation">.</span>value<span class="token punctuation">;</span> <span class="token comment">// Error</span>\n    parsed<span class="token punctuation">.</span>error<span class="token punctuation">;</span> <span class="token comment">// OK</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p>下面是在 <a href="https://code.visualstudio.com/" target="_blank" rel="noopener noreferrer">Visual Studio Code</a> 编辑器中的报错信息。注意，一些属性访问因为是无效的，会标红线提示：</p><p><img src="https://mariusschulz.com/images/content/typescript_boolean_literal_discriminant_property-2x.p4d5gfznrb.imm.png" alt="TypeScript checking for invalid property accesses"></p><p><code>parsed.success</code> 是 <a href="./tagged-union-types-in-typescript.html">区别属性</a>，所以在判断后，编译器只会允许我们访问 <code>value</code> 或 <code>error</code> 属性：</p><ul><li>如果 <code>parsed.success</code> 为 <code>true</code>，<code>parsed</code> 类型必然是 <code>{ success: true; value: string }</code>，所以可以访问 <code>value</code>，但不能访问 <code>error</code>。</li><li>如果 <code>parsed.success</code> 为 <code>false</code>，<code>parsed</code> 类型必然是 <code>{ success: true; error: string }</code>，所以可以访问 <code>error</code>，但不能访问 <code>value</code>。</li></ul><p>顺便说一下，你有没有注意到整个代码示例中唯一的 TypeScript 构件就是 <code>Result&lt;T&gt;</code> 声明和函数签名中的类型注解？其余的代码就是普通的 JavaScript。正是基于控制流的类型分析，让整块代码仍旧是完全类型化的。</p><h2 id="数值字面量类型"><a class="header-anchor" href="#数值字面量类型" aria-hidden="true">#</a> 数值字面量类型</h2><p>类似 <a href="./string-literal-types-in-typescript.html">字符串字面量</a>，我们可以将数值变量限制由已知值组成的有限集合:</p><div class="language-ts line-numbers-mode"><pre><code><span class="token keyword">let</span> zeroOrOne<span class="token operator">:</span> <span class="token number">0</span> <span class="token operator">|</span> <span class="token number">1</span><span class="token punctuation">;</span>\n\nzeroOrOne <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>\n<span class="token comment">// OK</span>\n\nzeroOrOne <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>\n<span class="token comment">// OK</span>\n\nzeroOrOne <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>\n<span class="token comment">// Error: Type &#39;2&#39; is not assignable to type &#39;0 | 1&#39;</span>\n</code></pre><div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><p>实践中，我们可以在处理端口号时使用数字字面量。不安全的 HTTP 使用端口 80，而 HTTPS 使用端口 443。我们可以编写一个 <code>getPort</code> 函数，并在函数签名中返回两个可能的返回值:</p><div class="language-ts line-numbers-mode"><pre><code><span class="token keyword">function</span> <span class="token function">getPort</span><span class="token punctuation">(</span>scheme<span class="token operator">:</span> <span class="token string">&quot;http&quot;</span> <span class="token operator">|</span> <span class="token string">&quot;https&quot;</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token number">80</span> <span class="token operator">|</span> <span class="token number">443</span> <span class="token punctuation">{</span>\n    <span class="token keyword">switch</span> <span class="token punctuation">(</span>scheme<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token keyword">case</span> <span class="token string">&quot;http&quot;</span><span class="token operator">:</span>\n            <span class="token keyword">return</span> <span class="token number">80</span><span class="token punctuation">;</span>\n        <span class="token keyword">case</span> <span class="token string">&quot;https&quot;</span><span class="token operator">:</span>\n            <span class="token keyword">return</span> <span class="token number">443</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n\n<span class="token keyword">const</span> httpPort <span class="token operator">=</span> <span class="token function">getPort</span><span class="token punctuation">(</span><span class="token string">&quot;http&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Type 80 | 443</span>\n</code></pre><div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><p>如果我们将字面量类型与 <a href="https://mariusschulz.com/blog/function-overloads-in-typescript" target="_blank" rel="noopener noreferrer">函数重载</a> 结合起来会更加有趣。通过给 <code>getPort</code> 函数不同的重载提供更具体的类型:</p><div class="language-ts line-numbers-mode"><pre><code><span class="token keyword">function</span> <span class="token function">getPort</span><span class="token punctuation">(</span>scheme<span class="token operator">:</span> <span class="token string">&quot;http&quot;</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token number">80</span><span class="token punctuation">;</span>\n<span class="token keyword">function</span> <span class="token function">getPort</span><span class="token punctuation">(</span>scheme<span class="token operator">:</span> <span class="token string">&quot;https&quot;</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token number">443</span><span class="token punctuation">;</span>\n<span class="token keyword">function</span> <span class="token function">getPort</span><span class="token punctuation">(</span>scheme<span class="token operator">:</span> <span class="token string">&quot;http&quot;</span> <span class="token operator">|</span> <span class="token string">&quot;https&quot;</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token number">80</span> <span class="token operator">|</span> <span class="token number">443</span> <span class="token punctuation">{</span>\n    <span class="token keyword">switch</span> <span class="token punctuation">(</span>scheme<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token keyword">case</span> <span class="token string">&quot;http&quot;</span><span class="token operator">:</span>\n            <span class="token keyword">return</span> <span class="token number">80</span><span class="token punctuation">;</span>\n        <span class="token keyword">case</span> <span class="token string">&quot;https&quot;</span><span class="token operator">:</span>\n            <span class="token keyword">return</span> <span class="token number">443</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n\n<span class="token keyword">const</span> httpPort <span class="token operator">=</span> <span class="token function">getPort</span><span class="token punctuation">(</span><span class="token string">&quot;http&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Type 80</span>\n<span class="token keyword">const</span> httpsPort <span class="token operator">=</span> <span class="token function">getPort</span><span class="token punctuation">(</span><span class="token string">&quot;https&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Type 443</span>\n</code></pre><div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div><p>现在编译器可以帮助我们检测总是为 <code>false</code> 的条件，例如将 <code>httpPort</code> 和 <code>443</code> 两个值进行比较:</p><p><img src="https://mariusschulz.com/images/content/typescript_control_flow_contradiction-2x.kpi7hrylto.imm.png" alt="TypeScript flagging a condition that&#39;s always false"></p><p>由于 <code>httpPort</code> 的类型是 <code>80</code>，它只可能是 80，不会等于 443。这种情况下，TypeScript 编译器可以帮助你检测出有 bug 的逻辑（buggy logic）或是死代码（dead code）。</p><h2 id="枚举字面量类型"><a class="header-anchor" href="#枚举字面量类型" aria-hidden="true">#</a> 枚举字面量类型</h2><p>Finally, we can also use enumerations as literal types. Continuing our example from before, we&#39;ll be implementing a function that maps from a given port (80 or 443) to the corresponding scheme (HTTP or HTTPS, respectively). To do that, we&#39;ll first declare a <a href="https://www.typescriptlang.org/docs/handbook/enums.html" target="_blank" rel="noopener noreferrer">const enum</a> which models the two port numbers:</p><p>最后，我们还可以使用枚举作为字面量类型。接着前面的示例，我们将实现一个函数，该函数从给定的端口（80 或 443）映射到相应的协议（分别是 HTTP 或 HTTPS）。为此，我们首先声明一个<a href="https://www.typescriptlang.org/docs/handbook/enums.html" target="_blank" rel="noopener noreferrer">const enum</a> 来模拟两个端口号:</p><div class="language-ts line-numbers-mode"><pre><code><span class="token keyword">const</span> <span class="token keyword">enum</span> HttpPort <span class="token punctuation">{</span>\n    Http <span class="token operator">=</span> <span class="token number">80</span><span class="token punctuation">,</span>\n    Https <span class="token operator">=</span> <span class="token number">443</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>现在，<code>getScheme</code> 函数同样使用函数重载进行类型注释:</p><div class="language-ts line-numbers-mode"><pre><code><span class="token keyword">function</span> <span class="token function">getScheme</span><span class="token punctuation">(</span>port<span class="token operator">:</span> HttpPort<span class="token punctuation">.</span>Http<span class="token punctuation">)</span><span class="token operator">:</span> <span class="token string">&quot;http&quot;</span><span class="token punctuation">;</span>\n<span class="token keyword">function</span> <span class="token function">getScheme</span><span class="token punctuation">(</span>port<span class="token operator">:</span> HttpPort<span class="token punctuation">.</span>Https<span class="token punctuation">)</span><span class="token operator">:</span> <span class="token string">&quot;https&quot;</span><span class="token punctuation">;</span>\n<span class="token keyword">function</span> <span class="token function">getScheme</span><span class="token punctuation">(</span>port<span class="token operator">:</span> HttpPort<span class="token punctuation">)</span><span class="token operator">:</span> <span class="token string">&quot;http&quot;</span> <span class="token operator">|</span> <span class="token string">&quot;https&quot;</span> <span class="token punctuation">{</span>\n    <span class="token keyword">switch</span> <span class="token punctuation">(</span>port<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token keyword">case</span> HttpPort<span class="token punctuation">.</span>Http<span class="token operator">:</span>\n            <span class="token keyword">return</span> <span class="token string">&quot;http&quot;</span><span class="token punctuation">;</span>\n        <span class="token keyword">case</span> HttpPort<span class="token punctuation">.</span>Https<span class="token operator">:</span>\n            <span class="token keyword">return</span> <span class="token string">&quot;https&quot;</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n\n<span class="token keyword">const</span> scheme <span class="token operator">=</span> <span class="token function">getScheme</span><span class="token punctuation">(</span>HttpPort<span class="token punctuation">.</span>Http<span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token comment">// Type &quot;http&quot;</span>\n</code></pre><div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div><p>Constant enumerations have no runtime manifestation (unless you provide the <code>preserveConstEnums</code> compiler option) — that is, the constant values of the enum cases will be inlined wherever they are used. Here&#39;s the compiled JavaScript code, with comments removed:</p><p>常量枚举没有运行时表现（除非提供 <code>PreserveConstenums</code> 编译器选项）——也就是说，枚举里的常量值会直接替换到行内，以下就是编译出来的 JavaScript 代码（移除了注释的）：</p><div class="language-ts line-numbers-mode"><pre><code><span class="token keyword">function</span> <span class="token function">getScheme</span><span class="token punctuation">(</span>port<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">switch</span> <span class="token punctuation">(</span>port<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token keyword">case</span> <span class="token number">80</span><span class="token operator">:</span>\n            <span class="token keyword">return</span> <span class="token string">&quot;http&quot;</span><span class="token punctuation">;</span>\n        <span class="token keyword">case</span> <span class="token number">443</span><span class="token operator">:</span>\n            <span class="token keyword">return</span> <span class="token string">&quot;https&quot;</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n<span class="token keyword">var</span> scheme <span class="token operator">=</span> <span class="token function">getScheme</span><span class="token punctuation">(</span><span class="token number">80</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n</code></pre><div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p>很简洁，不是吗？</p><p>本篇文章是 <a href="https://mariusschulz.com/blog/series/typescript-evolution" target="_blank" rel="noopener noreferrer">TypeScript Evolution</a> 系列中的一篇。</p>',46);p.render=function(a,e,p,o,c,r){return n(),s("div",null,[t])};export default p;export{e as __pageData};
