import{o as n,c as s,a}from"./app.808b26de.js";const e='{"title":"","description":"","frontmatter":{},"headers":[{"level":2,"title":"Boolean Literal Types\\n布尔字面量类型","slug":"boolean-literal-types布尔字面量类型"},{"level":2,"title":"Numeric Literal Types\\n数值字面量类型","slug":"numeric-literal-types数值字面量类型"},{"level":2,"title":"Enum Literal Types\\n枚举字面量类型","slug":"enum-literal-types枚举字面量类型"}],"relativePath":"typescript/more-literal-types-in-typescript.md","lastUpdated":1641043299478}',t={},p=a('<h1 id="typescript-2-0-中增加的字面量类型"><a class="header-anchor" href="#typescript-2-0-中增加的字面量类型" aria-hidden="true">#</a> TypeScript 2.0 中增加的字面量类型</h1><blockquote><p>Marius Schulz, <a href="https://mariusschulz.com/blog/more-literal-types-in-typescript" target="_blank" rel="noopener noreferrer">“More Literal Types in TypeScript”</a>, November 10, 2016</p></blockquote><p>TypeScript 1.8 introduced <a href="/blog/string-literal-types-in-typescript.html">string literal types</a> for restricting variables to a finite set of possible string values. With TypeScript 2.0, literal types are no longer restricted to string literals. The following literal types have been added to the type system:</p><ul><li><a href="#boolean-literal-types">Boolean literal types</a></li><li><a href="#numeric-literal-types">Numeric literal types</a></li><li><a href="#enum-literal-types">Enum literal types</a></li></ul><p>In the following sections, we&#39;re going to be looking at a practical example for each of these new literal types.</p><h2 id="boolean-literal-types布尔字面量类型"><a class="header-anchor" href="#boolean-literal-types布尔字面量类型" aria-hidden="true">#</a> Boolean Literal Types 布尔字面量类型</h2><p>The following example defines two constants, <code>TRUE</code> and <code>FALSE</code>, which hold the values <code>true</code> and <code>false</code>, respectively:</p><div class="language-ts line-numbers-mode"><pre><code><span class="token keyword">const</span> <span class="token constant">TRUE</span><span class="token operator">:</span> <span class="token boolean">true</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span> <span class="token comment">// OK</span>\n<span class="token keyword">const</span> <span class="token constant">FALSE</span><span class="token operator">:</span> <span class="token boolean">false</span> <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span> <span class="token comment">// OK</span>\n</code></pre><div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>Trying to assign the opposite boolean value to each of the local variables results in a type error:</p><div class="language-ts line-numbers-mode"><pre><code><span class="token keyword">const</span> <span class="token constant">TRUE</span><span class="token operator">:</span> <span class="token boolean">true</span> <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>\n<span class="token comment">// Error: Type &#39;false&#39; is not assignable to type &#39;true&#39;</span>\n\n<span class="token keyword">const</span> <span class="token constant">FALSE</span><span class="token operator">:</span> <span class="token boolean">false</span> <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>\n<span class="token comment">// Error: Type &#39;true&#39; is not assignable to type &#39;false&#39;</span>\n</code></pre><div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>With the introduction of boolean literal types, the predefined <code>boolean</code> type is now equivalent to the <code>true | false</code> union type:</p><div class="language-ts line-numbers-mode"><pre><code><span class="token keyword">let</span> value<span class="token operator">:</span> <span class="token boolean">true</span> <span class="token operator">|</span> <span class="token boolean">false</span><span class="token punctuation">;</span> <span class="token comment">// Type boolean</span>\n</code></pre><div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>While boolean literal types are rarely useful in isolation, they work great in conjunction with <a href="/blog/tagged-union-types-in-typescript.html">tagged union types</a> and <a href="/blog/control-flow-based-type-analysis-in-typescript.html">control flow based type analysis</a>. For instance, a generic <code>Result&lt;T&gt;</code> type that either holds a value of type <code>T</code> or an error message of type <code>string</code> can be defined as follows:</p><div class="language-ts line-numbers-mode"><pre><code><span class="token keyword">type</span> <span class="token class-name">Result<span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span></span> <span class="token operator">=</span>\n    <span class="token operator">|</span> <span class="token punctuation">{</span> success<span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">;</span> value<span class="token operator">:</span> <span class="token constant">T</span> <span class="token punctuation">}</span>\n    <span class="token operator">|</span> <span class="token punctuation">{</span> success<span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">;</span> error<span class="token operator">:</span> <span class="token builtin">string</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>\n</code></pre><div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>Here&#39;s a function that accepts a parameter .</p><div class="language-ts line-numbers-mode"><pre><code><span class="token keyword">function</span> <span class="token function">parseEmailAddress</span><span class="token punctuation">(</span>\n    input<span class="token operator">:</span> <span class="token builtin">string</span> <span class="token operator">|</span> <span class="token keyword">null</span> <span class="token operator">|</span> <span class="token keyword">undefined</span>\n<span class="token punctuation">)</span><span class="token operator">:</span> Result<span class="token operator">&lt;</span><span class="token builtin">string</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span>\n    <span class="token comment">// If the input is null, undefined, or the empty string</span>\n    <span class="token comment">// (all of which are falsy values), we return early.</span>\n    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>input<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">return</span> <span class="token punctuation">{</span>\n        success<span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span>\n        error<span class="token operator">:</span> <span class="token string">&quot;The email address cannot be empty.&quot;</span>\n    <span class="token punctuation">}</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n\n    <span class="token comment">// We&#39;re only checking that the input matches the pattern</span>\n    <span class="token comment">//   &lt;something&gt; @ &lt;something&gt; DOT &lt;something&gt;</span>\n    <span class="token comment">// to keep it simple. Properly validating email addresses</span>\n    <span class="token comment">// via regex is hard, so let&#39;s not even try here.</span>\n    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">^\\S[email protected]\\S+\\.\\S+$</span><span class="token regex-delimiter">/</span></span><span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span>input<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">return</span> <span class="token punctuation">{</span>\n        success<span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span>\n        error<span class="token operator">:</span> <span class="token string">&quot;The email address has an invalid format.&quot;</span>\n    <span class="token punctuation">}</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n\n    <span class="token comment">// At this point, control flow based type analysis</span>\n    <span class="token comment">// has determined that the input has type string.</span>\n    <span class="token comment">// Thus, we can assign input to the value property.</span>\n    <span class="token keyword">return</span> <span class="token punctuation">{</span>\n    success<span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>\n    value<span class="token operator">:</span> input\n    <span class="token punctuation">}</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br></div></div><p>Note that with the <code>strictNullChecks</code> option enabled, <code>string</code> is a <a href="/blog/non-nullable-types-in-typescript.html">non-nullable type</a>. In order for the function to accept a value of a nullable type for its <code>input</code> parameter, the <code>null</code> and <code>undefined</code> types must explicitly be included in the union type.</p><p>We can now call the <code>parseEmailFunction</code> as follows:</p><div class="language-ts line-numbers-mode"><pre><code><span class="token keyword">const</span> parsed <span class="token operator">=</span> <span class="token function">parseEmailAddress</span><span class="token punctuation">(</span><span class="token string">&quot;[email protected]&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n<span class="token keyword">if</span> <span class="token punctuation">(</span>parsed<span class="token punctuation">.</span>success<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    parsed<span class="token punctuation">.</span>value<span class="token punctuation">;</span> <span class="token comment">// OK</span>\n    parsed<span class="token punctuation">.</span>error<span class="token punctuation">;</span> <span class="token comment">// Error</span>\n<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>\n    parsed<span class="token punctuation">.</span>value<span class="token punctuation">;</span> <span class="token comment">// Error</span>\n    parsed<span class="token punctuation">.</span>error<span class="token punctuation">;</span> <span class="token comment">// OK</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p>Here&#39;s a screenshot of <a href="https://code.visualstudio.com/" target="_blank" rel="noopener noreferrer">Visual Studio Code</a> rendering the above code snippet. Notice that some property access expressions are underlined with red squigglies:</p><p><img src="https://mariusschulz.com/images/content/typescript_boolean_literal_discriminant_property-2x.p4d5gfznrb.imm.png" alt="TypeScript checking for invalid property accesses"></p><p>What&#39;s great about this is that the compiler only lets us the <code>value</code> or <code>error</code> properties after we&#39;ve checked <code>parsed.success</code>, our <a href="/blog/tagged-union-types-in-typescript.html">discriminant property</a>:</p><ul><li>If <code>parsed.success</code> is <code>true</code>, <code>parsed</code> must have type <code>{ success: true; value: string }</code>. We can access <code>value</code> in this case, but not <code>error</code>.</li><li>If <code>parsed.success</code> is <code>false</code>, <code>parsed</code> must have type <code>{ success: false; error: string }</code>. We can access <code>error</code> in this case, but not <code>value</code>.</li></ul><p>By the way, did you notice that the only TypeScript artifacts in this entire code example are the declaration of <code>Result&lt;T&gt;</code> and the type annotations in the function signature? The remainder of the code is plain, idiomatic JavaScript that is still fully typed due to control flow based type analysis.</p><h2 id="numeric-literal-types数值字面量类型"><a class="header-anchor" href="#numeric-literal-types数值字面量类型" aria-hidden="true">#</a> Numeric Literal Types 数值字面量类型</h2><p>Similar to <a href="/blog/string-literal-types-in-typescript.html">string literal types</a>, we can restrict numeric variables to a finite set of known values:</p><div class="language-ts line-numbers-mode"><pre><code><span class="token keyword">let</span> zeroOrOne<span class="token operator">:</span> <span class="token number">0</span> <span class="token operator">|</span> <span class="token number">1</span><span class="token punctuation">;</span>\n\nzeroOrOne <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>\n<span class="token comment">// OK</span>\n\nzeroOrOne <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>\n<span class="token comment">// OK</span>\n\nzeroOrOne <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>\n<span class="token comment">// Error: Type &#39;2&#39; is not assignable to type &#39;0 | 1&#39;</span>\n</code></pre><div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><p>In practice, we could use a numeric literal when working with port numbers, for example. Unsecured HTTP uses port 80, while HTTPS uses port 443. We can write a <code>getPort</code> function and encode the only two possible return values in its function signature:</p><div class="language-ts line-numbers-mode"><pre><code><span class="token keyword">function</span> <span class="token function">getPort</span><span class="token punctuation">(</span>scheme<span class="token operator">:</span> <span class="token string">&quot;http&quot;</span> <span class="token operator">|</span> <span class="token string">&quot;https&quot;</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token number">80</span> <span class="token operator">|</span> <span class="token number">443</span> <span class="token punctuation">{</span>\n    <span class="token keyword">switch</span> <span class="token punctuation">(</span>scheme<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">case</span> <span class="token string">&quot;http&quot;</span><span class="token operator">:</span>\n        <span class="token keyword">return</span> <span class="token number">80</span><span class="token punctuation">;</span>\n    <span class="token keyword">case</span> <span class="token string">&quot;https&quot;</span><span class="token operator">:</span>\n        <span class="token keyword">return</span> <span class="token number">443</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n\n<span class="token keyword">const</span> httpPort <span class="token operator">=</span> <span class="token function">getPort</span><span class="token punctuation">(</span><span class="token string">&quot;http&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Type 80 | 443</span>\n</code></pre><div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><p>It gets even more interesting if we combine literal types with <a href="/blog/function-overloads-in-typescript.html">TypeScript&#39;s function overloads</a>. That way, we can give more specific types to different overloads of the <code>getPort</code> function:</p><div class="language-ts line-numbers-mode"><pre><code><span class="token keyword">function</span> <span class="token function">getPort</span><span class="token punctuation">(</span>scheme<span class="token operator">:</span> <span class="token string">&quot;http&quot;</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token number">80</span><span class="token punctuation">;</span>\n<span class="token keyword">function</span> <span class="token function">getPort</span><span class="token punctuation">(</span>scheme<span class="token operator">:</span> <span class="token string">&quot;https&quot;</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token number">443</span><span class="token punctuation">;</span>\n<span class="token keyword">function</span> <span class="token function">getPort</span><span class="token punctuation">(</span>scheme<span class="token operator">:</span> <span class="token string">&quot;http&quot;</span> <span class="token operator">|</span> <span class="token string">&quot;https&quot;</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token number">80</span> <span class="token operator">|</span> <span class="token number">443</span> <span class="token punctuation">{</span>\n    <span class="token keyword">switch</span> <span class="token punctuation">(</span>scheme<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">case</span> <span class="token string">&quot;http&quot;</span><span class="token operator">:</span>\n        <span class="token keyword">return</span> <span class="token number">80</span><span class="token punctuation">;</span>\n    <span class="token keyword">case</span> <span class="token string">&quot;https&quot;</span><span class="token operator">:</span>\n        <span class="token keyword">return</span> <span class="token number">443</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n\n<span class="token keyword">const</span> httpPort <span class="token operator">=</span> <span class="token function">getPort</span><span class="token punctuation">(</span><span class="token string">&quot;http&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Type 80</span>\n<span class="token keyword">const</span> httpsPort <span class="token operator">=</span> <span class="token function">getPort</span><span class="token punctuation">(</span><span class="token string">&quot;https&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Type 443</span>\n</code></pre><div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div><p>Now, the compiler can help us when it detects conditions that are always return the value <code>false</code>, for example when comparing <code>httpPort</code> to the value <code>443</code>:</p><p><img src="https://mariusschulz.com/images/content/typescript_control_flow_contradiction-2x.kpi7hrylto.imm.png" alt="TypeScript flagging a condition that&#39;s always false"></p><p>Since <code>httpPort</code> has type <code>80</code>, it always contains the value 80, which of course is never equal to the value 443. In cases like these, the TypeScript compiler can help you detect both buggy logic and dead code.</p><h2 id="enum-literal-types枚举字面量类型"><a class="header-anchor" href="#enum-literal-types枚举字面量类型" aria-hidden="true">#</a> Enum Literal Types 枚举字面量类型</h2><p>Finally, we can also use enumerations as literal types. Continuing our example from before, we&#39;ll be implementing a function that maps from a given port (80 or 443) to the corresponding scheme (HTTP or HTTPS, respectively). To do that, we&#39;ll first declare a <a href="https://www.typescriptlang.org/docs/handbook/enums.html" target="_blank" rel="noopener noreferrer">const enum</a> which models the two port numbers:</p><div class="language-ts line-numbers-mode"><pre><code><span class="token keyword">const</span> <span class="token keyword">enum</span> HttpPort <span class="token punctuation">{</span>\n    Http <span class="token operator">=</span> <span class="token number">80</span><span class="token punctuation">,</span>\n    Https <span class="token operator">=</span> <span class="token number">443</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>Now comes our <code>getScheme</code> function, again using function overloads for specialized type annotations:</p><div class="language-ts line-numbers-mode"><pre><code><span class="token keyword">function</span> <span class="token function">getScheme</span><span class="token punctuation">(</span>port<span class="token operator">:</span> HttpPort<span class="token punctuation">.</span>Http<span class="token punctuation">)</span><span class="token operator">:</span> <span class="token string">&quot;http&quot;</span><span class="token punctuation">;</span>\n<span class="token keyword">function</span> <span class="token function">getScheme</span><span class="token punctuation">(</span>port<span class="token operator">:</span> HttpPort<span class="token punctuation">.</span>Https<span class="token punctuation">)</span><span class="token operator">:</span> <span class="token string">&quot;https&quot;</span><span class="token punctuation">;</span>\n<span class="token keyword">function</span> <span class="token function">getScheme</span><span class="token punctuation">(</span>port<span class="token operator">:</span> HttpPort<span class="token punctuation">)</span><span class="token operator">:</span> <span class="token string">&quot;http&quot;</span> <span class="token operator">|</span> <span class="token string">&quot;https&quot;</span> <span class="token punctuation">{</span>\n    <span class="token keyword">switch</span> <span class="token punctuation">(</span>port<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">case</span> HttpPort<span class="token punctuation">.</span>Http<span class="token operator">:</span>\n        <span class="token keyword">return</span> <span class="token string">&quot;http&quot;</span><span class="token punctuation">;</span>\n    <span class="token keyword">case</span> HttpPort<span class="token punctuation">.</span>Https<span class="token operator">:</span>\n        <span class="token keyword">return</span> <span class="token string">&quot;https&quot;</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n\n<span class="token keyword">const</span> scheme <span class="token operator">=</span> <span class="token function">getScheme</span><span class="token punctuation">(</span>HttpPort<span class="token punctuation">.</span>Http<span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token comment">// Type &quot;http&quot;</span>\n</code></pre><div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div><p>Constant enumerations have no runtime manifestation (unless you provide the <code>preserveConstEnums</code> compiler option) — that is, the constant values of the enum cases will be inlined wherever they are used. Here&#39;s the compiled JavaScript code, with comments removed:</p><div class="language-ts line-numbers-mode"><pre><code><span class="token keyword">function</span> <span class="token function">getScheme</span><span class="token punctuation">(</span>port<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">switch</span> <span class="token punctuation">(</span>port<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">case</span> <span class="token number">80</span><span class="token operator">:</span>\n        <span class="token keyword">return</span> <span class="token string">&quot;http&quot;</span><span class="token punctuation">;</span>\n    <span class="token keyword">case</span> <span class="token number">443</span><span class="token operator">:</span>\n        <span class="token keyword">return</span> <span class="token string">&quot;https&quot;</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n<span class="token keyword">var</span> scheme <span class="token operator">=</span> <span class="token function">getScheme</span><span class="token punctuation">(</span><span class="token number">80</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n</code></pre><div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p>Super clean, isn&#39;t it?</p><p>本篇文章是 <a href="https://mariusschulz.com/blog/series/typescript-evolution" target="_blank" rel="noopener noreferrer">TypeScript Evolution</a> 系列中的一篇。</p>',43);t.render=function(a,e,t,o,c,l){return n(),s("div",null,[p])};export default t;export{e as __pageData};
