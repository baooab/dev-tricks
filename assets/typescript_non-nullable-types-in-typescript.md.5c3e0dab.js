import{o as e,c as n,a as r}from"./app.d2ac5229.js";const t='{"title":"","description":"","frontmatter":{},"headers":[{"level":2,"title":"[#](#the-null-and-undefined-values) null 和 undefined","slug":"null-和-undefined"},{"level":2,"title":"[#](#strict-null-checking)严格空检查","slug":"严格空检查"},{"level":2,"title":"[#](#modeling-nullability-with-union-types)使用联合类型构建可为空变量","slug":"使用联合类型构建可为空变量"},{"level":2,"title":"[#](#property-access-with-nullable-types)访问可为空属性","slug":"访问可为空属性"},{"level":2,"title":"[#](#function-invocations-with-nullable-types)调用可为空函数","slug":"调用可为空函数"},{"level":2,"title":"[#](#summary)总结","slug":"总结"}],"relativePath":"typescript/non-nullable-types-in-typescript.md","lastUpdated":1640346338592}',o={},a=r('<h1 id="typescript-中的非空类型"><a class="header-anchor" href="#typescript-中的非空类型" aria-hidden="true">#</a> TypeScript 中的非空类型</h1><blockquote><p>Marius Schulz, <a href="https://mariusschulz.com/blog/non-nullable-types-in-typescript" target="_blank" rel="noopener noreferrer">“Non-Nullable Types in TypeScript”</a>, September 28, 2016</p></blockquote><p><a href="https://blogs.msdn.microsoft.com/typescript/2016/09/22/announcing-typescript-2-0/" target="_blank" rel="noopener noreferrer">TypeScript 2.0</a> 引入了很多新特性。本篇，我将介绍 <strong>非空类型</strong>，这是对类型系统的基础功能提升，帮助我们避免了编译期间的空值错误（nullability errors）。</p><h2 id="null-和-undefined"><a class="header-anchor" href="#null-和-undefined" aria-hidden="true">#</a> <a href="#the-null-and-undefined-values">#</a> <code>null</code> 和 <code>undefined</code></h2><p>TypeScript 2.0 之前，类型检查器（type checker）允许将 <code>null</code> 和 <code>undefined</code> 赋值给 <em>任意</em> 类型。这包括字符串、数值和布尔值在内的原始类型：</p><pre><code>let name: string;\nname = &quot;Marius&quot;;  // OK\nname = null;      // OK\nname = undefined; // OK\n\nlet age: number;\nage = 24;        // OK\nage = null;      // OK\nage = undefined; // OK\n\nlet isMarried: boolean;\nisMarried = true;      // OK\nisMarried = false;     // OK\nisMarried = null;      // OK\nisMarried = undefined; // OK\n</code></pre><p>以 <code>number</code> 类型为例。它所表示的范围不仅包括 <a href="https://en.wikipedia.org/wiki/IEEE_floating_point" target="_blank" rel="noopener noreferrer">IEEE 754 浮点数值</a>，还包括 <code>null</code> 和 <code>undefined</code>：</p><p><img src="https://mariusschulz.com/images/content/typescript_number_domain_with_null_and_undefined-2x.vzfjhvlgca.imm.png" alt="Domains of TypeScript&#39;s number type"></p><p>对象、数组和函数类型也是如此。但在这种类型系统下，无法表示非空的变量。幸运的是，TypeScript 2.0 修复了这个问题。</p><h2 id="严格空检查"><a class="header-anchor" href="#严格空检查" aria-hidden="true">#</a> <a href="#strict-null-checking">#</a>严格空检查</h2><p>TypeScritp 2.0 添加了对 <strong>非空类型（non-nullable types）</strong> 的支持。命令行中使用 <code>--strictNullChecks</code> flag 就能启用 <strong>严格空检查（strict null checking）</strong> 模式，或者在项目的 <em>tsconfig.json</em> 文件中增加 <code>strictNullChecks</code> 编译选项：</p><pre><code>{\n  &quot;compilerOptions&quot;: {\n    &quot;strictNullChecks&quot;: true\n    // ...\n  }\n}\n</code></pre><p>严格空检查模式下，<code>null</code> 和 <code>undefined</code> 不再能够赋值给任意类型。<code>null</code> 和 <code>undefined</code> 都归属在各自类型之下：</p><p><img src="https://mariusschulz.com/images/content/typescript_number_domain_without_null_and_undefined-2x.ni7cmeejbe.imm.png" alt="Domains of TypeScript&#39;s number, null, and undefined types"></p><p>启用严格空检查模式后，将 <code>null</code> 和 <code>undefined</code> 赋值给任何变量都会导致错误：</p><pre><code>// 使用 --strictNullChecks flag 编译的结果\n\nlet name: string;\nname = &quot;Marius&quot;;  // OK\nname = null;      // Error\nname = undefined; // Error\n\nlet age: number;\nage = 24;        // OK\nage = null;      // Error\nage = undefined; // Error\n\nlet isMarried: boolean;\nisMarried = true;      // OK\nisMarried = false;     // OK\nisMarried = null;      // Error\nisMarried = undefined; // Error\n</code></pre><p>那么，我们如何在 TypeScript 2.0 中表示可为空变量呢？</p><h2 id="使用联合类型构建可为空变量"><a class="header-anchor" href="#使用联合类型构建可为空变量" aria-hidden="true">#</a> <a href="#modeling-nullability-with-union-types">#</a>使用联合类型构建可为空变量</h2><p>由于启用严格空检查后，各个类型默认都是非空的，所以，我们需要明确告诉类型检查器一个变量是可为空的。这可以通过将 <code>null</code> 和 <code>undefined</code> 混入联合类型做到的：</p><pre><code>let name: string | null;\nname = &quot;Marius&quot;;  // OK\nname = null;      // OK\nname = undefined; // Error\n</code></pre><p>注意，<code>undefined</code> 并不是可以赋值给变量 <code>name</code> 的有效值，因为联合类型中并没有包含 <code>undefined</code>。</p><p>这种表示可为空变量的方式非常直观。我们以一个简单的 <code>User</code> 类型为例：</p><pre><code>type User = {\n  firstName: string;\n  lastName: string | undefined;\n};\n\nlet jane: User = { firstName: &quot;Jane&quot;, lastName: undefined };\nlet john: User = { firstName: &quot;John&quot;, lastName: &quot;Doe&quot; };\n</code></pre><p>我们可以通过在 <code>lastName</code> 后面加 <code>?</code> 的方式将属性标记为可选的。除此之外，<code>undefined</code> 会自动添加到联合类型。因此，下面的赋值都是类型正确（type-correct）的：</p><pre><code>type User = {\n  firstName: string;\n  lastName?: string;\n};\n\n// We can assign a string to the &quot;lastName&quot; property\nlet john: User = { firstName: &quot;John&quot;, lastName: &quot;Doe&quot; };\n\n// ... or we can explicitly assign the value undefined\nlet jane: User = { firstName: &quot;Jane&quot;, lastName: undefined };\n\n// ... or we can not define the property at all\nlet jake: User = { firstName: &quot;Jake&quot; };\n</code></pre><h2 id="访问可为空属性"><a class="header-anchor" href="#访问可为空属性" aria-hidden="true">#</a> <a href="#property-access-with-nullable-types">#</a>访问可为空属性</h2><p>如果一个对象变量是可为空的，直接访问它的任意属性都会导致编译期错误（compil-time error）：</p><pre><code>function getLength(s: string | null) {\n  // Error: Object is possibly &#39;null&#39;.\n  return s.length;\n}\n</code></pre><p>访问属性前，需要使用 type guard 保证访问对象属性是安全的：</p><pre><code>function getLength(s: string | null) {\n  if (s === null) {\n    return 0;\n  }\n\n  return s.length;\n</code></pre><p>TypeScript 理解 JavaScript 的真值语义（truthiness semantics），支持条件表达式中的 type guard。因此，下面这种检查方式也是可以的：</p><pre><code>function getLength(s: string | null) {\n  return s ? s.length : 0;\n}\n</code></pre><h2 id="调用可为空函数"><a class="header-anchor" href="#调用可为空函数" aria-hidden="true">#</a> <a href="#function-invocations-with-nullable-types">#</a>调用可为空函数</h2><p>如果一个函数是可为空的，直接调用它就会导致编译期错误（compil-time error）。以下面的 <code>callback</code> 参数为例：</p><pre><code>function doSomething(callback?: () =&gt; void) {\n  // Error: Object is possibly &#39;undefined&#39;.\n  callback();\n}\n</code></pre><p>类似于访问对象属性前的检查，在调用函数前也要先检查，以便确保不是空值：</p><pre><code>function doSomething(callback?: () =&gt; void) {\n  if (callback) {\n    callback();\n  }\n}\n</code></pre><p>如果喜欢，还能通过 <code>typeof</code> 操作符的返回值确保不是空值：</p><pre><code>function doSomething(callback?: () =&gt; void) {\n  if (typeof callback === &quot;function&quot;) {\n    callback();\n  }\n}\n</code></pre><h2 id="总结"><a class="header-anchor" href="#总结" aria-hidden="true">#</a> <a href="#summary">#</a>总结</h2><p>非空类型是 TypeScript 类型系统中非常基础和有价值的一个功能。它允许我们明确指定变量或属性是不是可为空，确保属性访问和函数调用是安全的，避免了编译期间的空值错误。</p><p>本篇文章是 <a href="https://mariusschulz.com/blog/series/typescript-evolution" target="_blank" rel="noopener noreferrer">TypeScript Evolution</a> 系列中的一篇。</p>',42);o.render=function(r,t,o,i,l,d){return e(),n("div",null,[a])};export default o;export{t as __pageData};
